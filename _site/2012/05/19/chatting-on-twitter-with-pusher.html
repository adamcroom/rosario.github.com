<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

	<!-- Basic Page Needs
  ================================================== -->
	<meta charset="utf-8">
	<title>Blog of Saro</title>
	<meta name="description" content="Blog of a software developer living and working in europe">
	<meta name="author" content="">

	<!-- Mobile Specific Metas
  ================================================== -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<!-- CSS
  ================================================== -->
	<link rel="stylesheet" href="/stylesheets/skeleton/base.css">
	<link rel="stylesheet" href="/stylesheets/skeleton/skeleton.css">
	<link rel="stylesheet" href="/stylesheets/skeleton/layout.css">
	<link rel="stylesheet" href="/stylesheets/main.css">
	<link rel="stylesheet" href="/stylesheets/docco.css">
	<link rel="stylesheet" href="/stylesheets/styles/googlecode.min.css">
	<!-- [if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif] -->

	<link rel="shortcut icon" href="/images/favicon.ico">
	<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png">
	<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
	<script src="/javascripts/highlight.pack.js"></script>


</head>
<body>
	<div class="container">
		<div class="four columns sidebar">
			<nav>
				<h4 id="logo">Blog of Saro</h4>
				<ul>
 					<li><a href="/">Home</a></li>
					<!-- li><a href="/archive">Archive</a></li> -->
					<h5> Rosario works and lives in London, he likes Brighton and loves Budapest. </h5>
					<h5 class="followme">You can follow me here:
						<a href="https://twitter.com/_sarhus">@_sarhus</a>
						<img src="/images/followme.png"/>
					</h5>
				</ul>
			</nav>

			&nbsp;
		</div>
		<div class="twelve columns content">
			<h1 class="title">Chatting on Twitter (1/2)</h1>
<p class="date"> 19 May 2012 </p>

<h3>Can we embed a chat widget on <strong>Twitter</strong>? Yes, with few tricks and <strong>Pusher</strong> we can create a widget and chat with our Twitter friends.</h3>

<p><img src="/images/screenshot.png" title="qop chat screenshot" alt="qop chat" /></p>

<h2>Overview: qop qop qop </h2>

<p>This is a short description of <strong>qop</strong>, a simple and unpretentious chat widget written in Ruby and Coffeescript.
It uses <a href="http://pusher.com/" title="Pusher">Pusher</a> to send chat messages to our  <a href="http://twitter.com/" title="Twitter">Twitter</a>
friends, and it can be embedded on a Twitter page.</p>

<p>Source code can be found here: <a href="https://github.com/rosario/qop" title="qop source">qop source</a></p>

<p>The technical part: Web services are provided with Sinatra. Authentication is done via Omniauth. Data models
are written in Datamapper, and Handlebars is used for templates. Finally a custom Sprockets process will glue
everything together. As easy as that!</p>

<p><img src="/images/qop2.png" title="qop drawing" alt="qop chat" /></p>

<h2>The bookmarklet</h2>

<p>The bookmarklet loads the widget from our server, and this is the code:</p>

<pre><code>  (function(){
    link = document.createElement('link');
    link.href = 'https://YOURQOPSERVER.herokuapp.com/assets/application.css';
    link.type = 'text/css';
    link.rel = 'stylesheet';
    document.getElementsByTagName('head')[0].appendChild(link);

    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.async = true;
    script.src = 'https://YOURQOPSERVER.herokuapp.com/assets/application.js';
    document.getElementsByTagName('head')[0].appendChild(script);
  })();
</code></pre>

<p>Note that it will be easy to create a Chrome Extension, just add a <em>manifest.json</em> and Chrome will do the rest. The
file <em>application.js</em> contains the entire javascript code for the widget.</p>

<h2>Loading, please wait</h2>

<p>We load jQuery and wait until is ready to be used. We also need to load Pusher library, and finally load <strong>qop</strong>.</p>

<pre><code>  # Load jQuery
  done = false
  script = document.createElement('script')
  script.src = 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js'

  script.onload = script.onreadystatechange = -&gt;
    if (!done and (!@readyState or @readyState =='loaded' or @readyState =='complete'))
      done = true
      # Assign jQuery to a local namespace
      window.qop$ = jQuery.noConflict();
      window.qop$.support.cors = true
      # Load Pusher library
      qop$.getScript("https://d3dy5gmtp8yhk7.cloudfront.net/1.11/pusher.min.js")
        .done (script) -&gt;
          console.log 'loading app...'
          app = new QoP.App()
        .fail (jqxhr, settings, exception) -&gt;
          console.log 'failed'

  document.getElementsByTagName('head')[0].appendChild(script)
</code></pre>

<p>The <strong>App</strong> class doesn't do much, just initialise Pusher with the right credentials, and creates the contact list.</p>

<pre><code>  class QoP.App
    constructor: -&gt;
      # Attach the widget to the page
      qop$('&lt;div id="qop"&gt;&lt;/div&gt;').appendTo 'body'
      # Setup Pusher
      Pusher.channel_auth_endpoint = 'https://YOURQOPSERVER.herokuapp.com/pusher/auth'
      Pusher.channel_auth_transport = 'jsonp'
      QoP.pusher = new Pusher 'APPKEY'
      #Load the contact list
      contacts = new QoP.Contacts('contact_list', 'Contact List')
</code></pre>

<h2>You're a bit too Pushy</h2>

<p><a href="http://pusher.com/" title="Pusher">Pusher</a> provides a great <strong>websockets</strong> service and API, and we use websockets to send chat messages
to our twitter friends.</p>

<p><img src="/images/pusher.png" title="QoP Chat" alt="qop chat" /></p>

<p>The browser sends <em>AJAX</em> requests to our server. Since the chat widget is loaded from <em>twitter.com</em>, we are
doing cross domain requests. CORS stands for Cross-Origin Resource Sharing, and it does what it says. Modern
browsers support CORS, and we only care about modern browsers. We could use JSONP, but that is really old school
(and CORS is more elegant).</p>

<p>The browser makes <em>CORS</em> requests to our server using jQuery:</p>

<pre><code>  class QoP.Server
    @sendRequest: (service_name, data = null, callback = null) -&gt;
      qop$.support.cors = true
      response = qop$.ajax "https://YOURQOPSERVER.herokuapp.com/#{service_name}",
        type: "POST"
        data: data
        contentType: "application/json; charset=utf-8"
        dataType: 'json'
        beforeSend: ( xhr ) -&gt;
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
            xhr.withCredentials = true
        success: (data) -&gt;
          callback(data) if callback
        error: (XMLHttpRequest, textStatus, errorThrown) -&gt;
          console.log "Error =&gt; #{textStatus}"
          console.log errorThrown
        xhrFields:
           withCredentials: true
        crossDomain: true
      return
</code></pre>

<p>We force jQuery to use <strong>cors</strong>, by setting a flag to true, we also need to pass <em>xhrFields</em>
and set <strong>withCredentials</strong> to true. It shouldn't be needed, but just in case we also set <strong>crossDomain</strong>
to true. It is a bit redundant, but there have been cases it won't work otherwise. If you know
any better way of doing this, please let me know.</p>

<p>The server needs to know we want to accept requests from <em>twitter.com</em>. Since the server is a <strong>Sinatra</strong>
application we use the <strong>rack-cors</strong> gem. (You want to include localhost for testing).</p>

<pre><code># This goes in the Gemfile
gem 'rack-cors', :require =&gt; 'rack/cors'

# This goes in the sinatra app.rb file
require 'rack/cors'

use Rack::Cors do
  allow do
    origins 'http://localhost:5000', 'https://twitter.com'
    # /messages is used to send messages to a channel
    resource '/messages',  
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true

    # /messages_all is used to send messages to a public channel            
    resource '/messages_all', 
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true

    # /chat_session gives informations about the connect user            
    resource '/chat_session', 
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true

    # /chat_request ask the server a private channel to connect two users
    resource '/chat_request', 
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true

    # pusher/auth is used to authenticate pusher presence channels
    resource '/pusher/auth', 
        :methods =&gt; [:get, :options],  :headers =&gt; :any, :credentials =&gt; true
  end
end
</code></pre>

<p>Each url corresponds to a service we provide to the chat widget.</p>

<h2>My Friends are your Friends</h2>

<p>Let's see how to populate the contact list</p>

<pre><code>class QoP.Contacts extends QoP.Box
  constructor: (id, name) -&gt;
    @presenceChannel = null
    @friends = null   # List of online friends
    @uid = null       # twitter uid
    @online = null    # if the user is online/offline
    @nickname = null  # the user nickname

    @bind 'qop:init_presence', @initPresenceChannel

    QoP.Server.sendRequest 'chat_session', null, (data) =&gt;
      @friends = data.friends
      @uid = data.uid
      @online = data.online == "true"
      @nickname = data.nickname
      content = qop$(JST['content'](id: "content_#{id}"))
      @box.append content 
      @trigger 'qop:init_presence'
</code></pre>

<p>The <strong>chat_session</strong> method returns a JSON object with user's online <em>@friends</em>,  <em>@uid</em>
(unique identifier provided by Twitter) and  <em>@nickname</em>. Note, <strong>online</strong> means the user has  been
authenticated with our server. (The <strong>JST</strong> variable is generated by Sprockets and it holds our
handlebars templates).</p>

<p>The <strong>initPresenceChannel</strong> function is called (via a trigger) if <em>chat_session</em> request is succesful.</p>

<pre><code>initPresenceChannel: -&gt;
  if @online
    @presenceChannel = QoP.pusher.subscribe("presence-#{@uid}")
    @presenceChannel.bind 'pusher:subscription_succeeded', @presenceSucceeded
    @presenceChannel.bind 'friend_status', @updateFriendStatus
    @presenceChannel.bind 'create_chat', @createChat
  else
    @box.find('.contactlist').append qop$(JST['signup']({redirect: redirectUrl}))
    @trigger 'box:raise'
  return
</code></pre>

<p>If the user is online (authenticated) we subscribe the user to <strong>his own</strong> presence channel.
If the user is not  online, we will show a signup link inside the widget, asking the user to authenticate.
Authentication is done via the <strong>omniauth-twitter</strong> gem.</p>

<h2>Presence Channels with Pusher</h2>

<p>Each user has got a <em>personal</em> presence channel. We use this channel to communicate events to the user.
For example, we use the presence channel to let a user when a friend <em>joins</em> or <em>leaves</em>
the chat. Pusher makes it really easy to know about these events via <strong>webhooks</strong>. Here's the server code:</p>

<pre><code>post '/webhooks' do
  webhook = Pusher::WebHook.new(request)
  if webhook.valid?
    webhook.events.each do |event|
      uid = event["channel"].split('-').last
      user = User.first(:uid=&gt;uid)
      if user
        case event["name"]
          when 'channel_occupied'
            user.online!
          when 'channel_vacated'
            user.offline!
        end
        user.online_friends.each do |friend|
          Pusher["presence-#{friend.uid}"].trigger_async('friend_status',{ 
              :uid =&gt; user.uid, 
              :nickname =&gt; user.nickname, 
              :online =&gt;user.online
          })
        end
      end
    end
  else
    status 401
  end
  return
end
</code></pre>

<p>When the user occupies the channel, the user status will be set to <em>online</em>, otherwise the user is <em>offline</em>.
We use "cowboy" notifications to send these status changes, for each online friend we send a <em>friend_status</em>
notification. Having said that, the code is highly inefficient, since we shouldn't do that, It would be better
to send notifications outside the http request cycle... Anyway...</p>

<h2>Look Ma, I have a friend</h2>

<p>At this point the user is authenticated and his presence channel is working. It's time to show/hide friends
and to open a chat box when we click on their nickname.</p>

<pre><code>presenceSucceeded: =&gt;
  @trigger 'box:raise'
  for user in @friends
    console.log "Render user: #{user.nickname}"
    @addFriend(user)
  return

updateFriendStatus: (user) =&gt;
  if user.online then @addFriend(user) else @removeFriend(user)
  return    

addFriend: (user) -&gt;
  check = @box.find("#contact_#{user.uid}").length == 0
  if check
    friend = qop$(JST['friend'](user: user))
    @box.find('.friends_list').append friend
    friend.bind 'click', {user: user}, (event) =&gt;
      QoP.Server.sendRequest('chat_request', {uid: event.data.user.uid})
  return

removeFriend: (user) -&gt;
  @box.find(".friends_list p#contact_#{user.uid}").remove()
  return
</code></pre>

<p>Adding an online friend is easy, we check if the friend isn't already shown, then we fill a template
with the relevant data, and we append this template to the contact list. To remove an offline
friend is even easier.</p>

<p>Now we need to create a chat box. Pusher is here to help us again. We bind the click event so that
when we click on the nickname the browser does an <em>AJAX</em> <strong>chat_request</strong> to our server.</p>

<pre><code>post '/chat_request' do
  someone = User.first(:uid=&gt; params[:uid])
  if someone and someone.online and current_user.friend?(someone)
    cuid = current_user.uid
    suid = someone.uid

    # A chat between two user is created using their twitter uids
    if cuid &lt; suid
      chat_channel = "chat-channel-#{cuid}-#{suid}"
    else
      chat_channel = "chat-channel-#{suid}-#{cuid}"
    end

    Pusher["presence-#{current_user.uid}"].trigger_async('create_chat', {
      :uid =&gt;someone.uid,
      :nickname=&gt;someone.nickname,
      :channel_name =&gt; chat_channel
    })

    Pusher["presence-#{someone.uid}"].trigger_async('create_chat',{
      :uid =&gt; current_user.uid,
      :nickname =&gt;current_user.nickname,
      :channel_name =&gt; chat_channel
    })

  end
  content_type :json
  {:request =&gt; 'sent'}.to_json
end
</code></pre>

<p>If our friend is online we create a new channel. This channel holds the chat between the two users.
We use Pusher to trigger a <strong>create_chat</strong> event in the browsers.</p>

<pre><code>createChat: (data) =&gt;
  channel_name = data.channel_name
  friend =  uid: data.uid, nickname: data.nickname
  user = uid: @uid, nickname: @nickname
  panel =  new QoP.Panel(channel_name, friend, user)
  return
</code></pre>

<p>The <em>createChat</em> creates a new Panel, and it allows us to chat with our friend.</p>

<h2>Panel Discussions</h2>

<p>The Panel is where we type our messages and chat with our friend. Each Panel has a pusher channel associated
with it, and this channel is used to send chat messages.</p>

<pre><code>class QoP.Panel extends QoP.Box
  constructor: (channel_name,friend = {}, user = {}) -&gt;
    @channel = null
    @channel_name = channel_name
    @name = null
    @user = user
    @friend = friend
</code></pre>

<p>To create the Panel, we render the template and append a text area.</p>

<pre><code>createBox: -&gt;
  panel = qop$(JST['panel'](id: "panel_#{@friend.uid}"))
  @box.append panel
  textarea = qop$(JST['textarea'](uid: @friend.uid))
  @box.append textarea
</code></pre>

<p>We also need to subscribe the users to the new channel.</p>

<pre><code>createChannel: -&gt;
  if not @channel?
    @channel = QoP.pusher.subscribe(@channel_name)
    @channel.bind 'pusher:subscription_succeeded', console.log("User subscribed")
    @channel.bind 'pusher:subscription_error', console.log('User already subscribed')
    @channel.bind 'new_message', @messageReceived
  @channel
</code></pre>

<p>Twitter has keyboard shortcuts, we need to disable them when the user is typing. After the user hits <em>enter</em>
we send the message to our server:</p>

<pre><code>enableTextBox: -&gt;
  textBox = @box.find('.chatboxtextarea')
  textBox.keypress (e) =&gt;
    e.stopPropagation()
  textBox.keydown (e) =&gt;
    e.stopPropagation()
    code = if e.keyCode then e.keyCode else e.which
    if code == 13
      text = textBox.val()
      textBox.val ""
      e.preventDefault()
      if text != ""
        data = uid: @friend.uid , text: text, channel_name: @channel_name
        QoP.Server.sendRequest('messages',data)
    return
</code></pre>

<p>Eventually, we'll also receive a message. Again, we render the message using handlebars template and append
the message to the Panel. We also need to scroll the content all the way up to the top, so that we can read
the message when it arrives.</p>

<pre><code>messageReceived: (data) =&gt;
  nickname = data.nickname
  message = JST['message'](text: data.text, nickname: nickname)
  @box.find('.chatboxcontent').append(message)
  @box.find('.chatboxcontent').scrollTop 10000000
  return
</code></pre>

<h2>Conclusions</h2>

<p>There's a lot more to say, we still have to see how to use Omniauth to authenticate the user, how to use
DelayedJob to fetch friends data in background, how to setup a custom Sprockets without Rails, and the database
relations and models used.</p>

<p>But that will be the subject of the next post!</p>



<h2>Archive</h2>

<div id="post_links">
	<ul>
		
			<li><span>31 May 2012</span>  <a href="/2012/05/31/chatting-on-twitter-with-pusher-part2.html">Chatting on Twitter (2/2)</a></li>
		
			<li><span>19 May 2012</span>  <a href="/2012/05/19/chatting-on-twitter-with-pusher.html">Chatting on Twitter (1/2)</a></li>
			
	</ul>
</div>


	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'rosario'; 
		var disqus_developer = 0; // developer mode is on
	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();
	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

		</div>
		
		<!-- <div class="sixteen columns footer"></div> -->
	</div>
	<script>hljs.initHighlightingOnLoad();</script>
	
	<script type="text/javascript">

	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-31897052-1']);
	  _gaq.push(['_trackPageview']);

	  (function() {
	    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();

	</script>	
</body>
</html>