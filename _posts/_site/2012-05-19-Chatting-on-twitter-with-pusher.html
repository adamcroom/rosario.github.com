<h3 id='can_we_embed_a_chat_widget_on_twitter_yes_with_few_tricks_and_pusher_we_can_create_a_widget_and_chat_with_our_twitter_friends'>Can we embed a chat widget on <strong>Twitter</strong>? Yes, with few tricks and <strong>Pusher</strong> we can create a widget and chat with our Twitter friends.</h3>

<p><img alt='qop chat' src='/images/screenshot.png' /></p>

<h2 id='overview_qop_qop_qop'>Overview: qop qop qop</h2>

<p>This is a short description of <strong>qop</strong>, a simple and unpretentious chat widget written in Ruby and Coffeescript. It uses <a href='http://pusher.com/' title='Pusher'>Pusher</a> to send chat messages to our <a href='http://twitter.com/' title='Twitter'>Twitter</a> friends, and it can be embedded on a Twitter page.</p>

<p>The technical part: Web services are provided with Sinatra. Authentication is done via Omniauth. Data models are written in Datamapper, and Handlebars is used for templates.</p>

<p>Finally a custom Sprockets process will glue everything together. As easy as that!</p>

<p><img alt='qop chat' src='/images/qop2.png' /></p>

<h2 id='the_bookmarklet'>The bookmarklet</h2>

<p>The bookmarklet loads the widget from our server, and this is the code:</p>

<pre><code>(function(){
  link = document.createElement(&#39;link&#39;);
  link.href = &#39;https://YOURQOPSERVER.herokuapp.com/assets/application.css&#39;;
  link.type = &#39;text/css&#39;;
  link.rel = &#39;stylesheet&#39;;
  document.getElementsByTagName(&#39;head&#39;)[0].appendChild(link);

  var script = document.createElement(&#39;script&#39;);
  script.type = &#39;text/javascript&#39;;
  script.async = true;
  script.src = &#39;https://YOURQOPSERVER.herokuapp.com/assets/application.js&#39;;
  document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);
})();</code></pre>

<p>Note that it will be easy to create a Chrome Extension, just add a <em>manifest.json</em> and Chrome will do the rest. The file <em>application.js</em> contains the entire javascript code for the widget.</p>

<h2 id='loading_please_wait'>Loading, please wait</h2>

<p>We load jQuery and wait until is ready to be used. We also need to load Pusher library, and finally load <strong>qop</strong>.</p>

<pre><code> done = false
  script = document.createElement(&#39;script&#39;)
  script.src = &#39;https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js&#39;
  
  script.onload = script.onreadystatechange = -&gt;
    if (!done and (!@readyState or @readyState ==&#39;loaded&#39; or @readyState ==&#39;complete&#39;))
      done = true
      
      window.qop$ = jQuery.noConflict();
      window.qop$.support.cors = true
      
      qop$.getScript(&quot;https://d3dy5gmtp8yhk7.cloudfront.net/1.11/pusher.min.js&quot;)
        .done (script) -&gt;
          console.log &#39;loading app...&#39;
          app = new QoP.App()
        .fail (jqxhr, settings, exception) -&gt;
          console.log &#39;failed&#39;
          
  document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script)</code></pre>

<p>The <strong>App</strong> class doesn&#8217;t do much, just initialise Pusher with the right credentials, and creates the contact list.</p>

<pre><code>class QoP.App
  constructor: -&gt;
    qop$(&quot;&lt;div id=&#39;qop&#39;&gt;&lt;/div&gt;&quot;).appendTo &#39;body&#39;
    Pusher.channel_auth_endpoint = &#39;https://YOURQOPSERVER.herokuapp.com/pusher/auth&#39;
    Pusher.channel_auth_transport = &#39;jsonp&#39;
    QoP.pusher = new Pusher &#39;APPKEY&#39;
    contacts = new QoP.Contacts(&#39;contact_list&#39;, &#39;Contact List&#39;)</code></pre>

<h2 id='youre_a_bit_too_pushy'>You&#8217;re a bit too Pushy</h2>

<p><a href='http://pusher.com/' title='Pusher'>Pusher</a> provides a great <strong>websockets</strong> service and API, and we use websockets to send chat messages to our twitter friends.</p>

<p><img alt='qop chat' src='/images/pusher.png' /></p>

<p>The browser sends <em>AJAX</em> requests to our server. Since the chat widget is loaded from <em>twitter.com</em>, we are doing cross domain requests. CORS stands for Cross-Origin Resource Sharing, and it does what it says. Modern browsers support CORS, and we only care about modern browsers. We could use JSONP, but that is really old school (and CORS is more elegant).</p>

<p>The browser makes <em>CORS</em> requests to our server using jQuery:</p>

<pre><code>  class QoP.Server
    @sendRequest: (service_name, data = null, callback = null) -&gt;
      qop$.support.cors = true
      response = qop$.ajax &quot;https://YOURQOPSERVER.herokuapp.com/#{service_name}&quot;,
        type: &quot;POST&quot;
        data: data
        contentType: &quot;application/json; charset=utf-8&quot;
        dataType: &#39;json&#39;
        beforeSend: ( xhr ) -&gt;
            xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
            xhr.withCredentials = true
        success: (data) -&gt;
          callback(data) if callback
        error: (XMLHttpRequest, textStatus, errorThrown) -&gt;
          console.log &quot;Error =&gt; #{textStatus}&quot;
          console.log errorThrown
        xhrFields:
           withCredentials: true
        crossDomain: true
      return</code></pre>

<p>We force jQuery to use <strong>cors</strong>, by setting a flag to true, we also need to pass <em>xhrFields</em> and set <strong>withCredentials</strong> to true. It shouldn&#8217;t be needed, but just in case we also set <strong>crossDomain</strong> to true. It is a bit redundant, but there have been cases it won&#8217;t work otherwise. If you know any better way of doing this, please let me know.</p>

<p>The server needs to know we want to accept requests from <em>twitter.com</em>. Since the server is a <strong>Sinatra</strong> application we use the <strong>rack-cors</strong> gem. (You want to include localhost for testing).</p>

<pre><code># This goes in the Gemfile
gem &#39;rack-cors&#39;, :require =&gt; &#39;rack/cors&#39;

# This goes in the sinatra app.rb file
require &#39;rack/cors&#39;

use Rack::Cors do
  allow do
    origins &#39;http://localhost:5000&#39;, &#39;https://twitter.com&#39;
    # /messages is used to send messages to a channel
    resource &#39;/messages&#39;,  
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true
        
    # /messages_all is used to send messages to a public channel            
    resource &#39;/messages_all&#39;, 
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true
        
    # /chat_session gives informations about the connect user            
    resource &#39;/chat_session&#39;, 
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true
        
    # /chat_request ask the server a private channel to connect two users
    resource &#39;/chat_request&#39;, 
        :methods =&gt; [:post, :options], :headers =&gt; :any, :credentials =&gt; true
        
    # pusher/auth is used to authenticate pusher presence channels
    resource &#39;/pusher/auth&#39;, 
        :methods =&gt; [:get, :options],  :headers =&gt; :any, :credentials =&gt; true
  end
end</code></pre>

<p>Each url corresponds to a service we provide to the chat widget.</p>

<h2 id='my_friends_are_your_friends'>My Friends are your Friends</h2>

<p>Let&#8217;s see how to populate the contact list</p>

<pre><code>class QoP.Contacts extends QoP.Box
  constructor: (id, name) -&gt;
    @presenceChannel = null
    @friends = null   # List of online friends
    @uid = null       # twitter uid
    @online = null    # if the user is online/offline
    @nickname = null  # the user nickname
    
    @bind &#39;qop:init_presence&#39;, @initPresenceChannel
    
    QoP.Server.sendRequest &#39;chat_session&#39;, null, (data) =&gt;
      @friends = data.friends
      @uid = data.uid
      @online = data.online == &quot;true&quot;
      @nickname = data.nickname
      content = qop$(JST[&#39;content&#39;](id: &quot;content_#{id}&quot;))
      @box.append content 
      @trigger &#39;qop:init_presence&#39;</code></pre>

<p>The <strong>chat_session</strong> method returns a JSON object with user&#8217;s online <em>@friends</em>, <em>@uid</em> (unique identifier provided by Twitter) and <em>@nickname</em>. Note, <strong>online</strong> means the user has been authenticated with our server. (The <strong>JST</strong> variable is generated by Sprockets and it holds our handlebars templates).</p>

<p>The <strong>initPresenceChannel</strong> function is called (via a trigger) if <em>chat_session</em> request is succesful.</p>

<pre><code>initPresenceChannel: -&gt;
  if @online
    @presenceChannel = QoP.pusher.subscribe(&quot;presence-#{@uid}&quot;)
    @presenceChannel.bind &#39;pusher:subscription_succeeded&#39;, @presenceSucceeded
    @presenceChannel.bind &#39;friend_status&#39;, @updateFriendStatus
    @presenceChannel.bind &#39;create_chat&#39;, @createChat
  else
    @box.find(&#39;.contactlist&#39;).append qop$(JST[&#39;signup&#39;]({redirect: redirectUrl}))
    @trigger &#39;box:raise&#39;
  return</code></pre>

<p>If the user is online (authenticated) we subscribe the user to <strong>his own</strong> presence channel. If the user is not online, we will show a signup link inside the widget, asking the user to authenticate. Authentication is done via the <strong>omniauth-twitter</strong> gem.</p>

<h2 id='presence_channels_with_pusher'>Presence Channels with Pusher</h2>

<p>Each user has got a <em>personal</em> presence channel. We use this channel to communicate events to the user. For example, we use the presence channel to let a user when a friend <em>joins</em> or <em>leaves</em> the chat. Pusher makes it really easy to know about these events via <strong>webhooks</strong>. Here&#8217;s the server code:</p>

<pre><code>post &#39;/webhooks&#39; do
  webhook = Pusher::WebHook.new(request)
  if webhook.valid?
    webhook.events.each do |event|
      uid = event[&quot;channel&quot;].split(&#39;-&#39;).last
      user = User.first(:uid=&gt;uid)
      if user
        case event[&quot;name&quot;]
          when &#39;channel_occupied&#39;
            user.online!
          when &#39;channel_vacated&#39;
            user.offline!
        end
        user.online_friends.each do |friend|
          Pusher[&quot;presence-#{friend.uid}&quot;].trigger_async(&#39;friend_status&#39;,{ 
              :uid =&gt; user.uid, 
              :nickname =&gt; user.nickname, 
              :online =&gt;user.online
          })
        end
      end
    end
  else
    status 401
  end
  return
end</code></pre>

<p>When the user occupies the channel, the user status will be set to <em>online</em>, otherwise the user is <em>offline</em>. We use &#8220;cowboy&#8221; notifications to send these status changes, for each online friend we send a <em>friend_status</em> notification. Having said that, the code is highly inefficient, since we shouldn&#8217;t do that, It would be better to send notifications outside the http request cycle&#8230; Anyway&#8230;</p>

<h2 id='look_ma_i_have_a_friend'>Look Ma, I have a friend</h2>

<p>At this point the user is authenticated and his presence channel is working. It&#8217;s time to show/hide friends and to open a chat box when we click on their nickname.</p>

<pre><code>presenceSucceeded: =&gt;
  @trigger &#39;box:raise&#39;
  for user in @friends
    console.log &quot;Render user: #{user.nickname}&quot;
    @addFriend(user)
  return

updateFriendStatus: (user) =&gt;
  if user.online then @addFriend(user) else @removeFriend(user)
  return    

addFriend: (user) -&gt;
  check = @box.find(&quot;#contact_#{user.uid}&quot;).length == 0
  if check
    friend = qop$(JST[&#39;friend&#39;](user: user))
    @box.find(&#39;.friends_list&#39;).append friend
    friend.bind &#39;click&#39;, {user: user}, (event) =&gt;
      QoP.Server.sendRequest(&#39;chat_request&#39;, {uid: event.data.user.uid})
  return

removeFriend: (user) -&gt;
  @box.find(&quot;.friends_list p#contact_#{user.uid}&quot;).remove()
  return</code></pre>

<p>Adding an online friend is easy, we check if the friend isn&#8217;t already shown, then we fill a template with the relevant data, and we append this template to the contact list. To remove an offline friend is even easier.</p>

<p>Now we need to create a chat box. Pusher is here to help us again. We bind the click event so that when we click on the nickname the browser does an <em>AJAX</em> <strong>chat_request</strong> to our server.</p>

<pre><code>post &#39;/chat_request&#39; do
  someone = User.first(:uid=&gt; params[:uid])
  if someone and someone.online and current_user.friend?(someone)
    cuid = current_user.uid
    suid = someone.uid
    
    # A chat between two user is created using their twitter uids
    if cuid &lt; suid
      chat_channel = &quot;chat-channel-#{cuid}-#{suid}&quot;
    else
      chat_channel = &quot;chat-channel-#{suid}-#{cuid}&quot;
    end
    
    Pusher[&quot;presence-#{current_user.uid}&quot;].trigger_async(&#39;create_chat&#39;, {
      :uid =&gt;someone.uid,
      :nickname=&gt;someone.nickname,
      :channel_name =&gt; chat_channel
    })
    
    Pusher[&quot;presence-#{someone.uid}&quot;].trigger_async(&#39;create_chat&#39;,{
      :uid =&gt; current_user.uid,
      :nickname =&gt;current_user.nickname,
      :channel_name =&gt; chat_channel
    })
    
  end
  content_type :json
  {:request =&gt; &#39;sent&#39;}.to_json
end</code></pre>

<p>If our friend is online we create a new channel. This channel holds the chat between the two users. We use Pusher to trigger a <strong>create_chat</strong> event in the browsers.</p>

<pre><code>createChat: (data) =&gt;
  channel_name = data.channel_name
  friend =  uid: data.uid, nickname: data.nickname
  user = uid: @uid, nickname: @nickname
  panel =  new QoP.Panel(channel_name, friend, user)
  return</code></pre>

<p>The <em>createChat</em> creates a new Panel, and it allows us to chat with our friend.</p>

<h2 id='panel_discussions'>Panel Discussions</h2>

<p>The Panel is where we type our messages and chat with our friend. Each Panel has a pusher channel associated with it, and this channel is used to send chat messages.</p>

<pre><code>class QoP.Panel extends QoP.Box
  constructor: (channel_name,friend = {}, user = {}) -&gt;
    @channel = null
    @channel_name = channel_name
    @name = null
    @user = user
    @friend = friend</code></pre>

<p>To create the Panel, we render the template and append a text area.</p>

<pre><code>createBox: -&gt;
  panel = qop$(JST[&#39;panel&#39;](id: &quot;panel_#{@friend.uid}&quot;))
  @box.append panel
  textarea = qop$(JST[&#39;textarea&#39;](uid: @friend.uid))
  @box.append textarea</code></pre>

<p>We also need to subscribe the users to the new channel.</p>

<pre><code>createChannel: -&gt;
  if not @channel?
    @channel = QoP.pusher.subscribe(@channel_name)
    @channel.bind &#39;pusher:subscription_succeeded&#39;, console.log(&quot;User subscribed&quot;)
    @channel.bind &#39;pusher:subscription_error&#39;, console.log(&#39;User already subscribed&#39;)
    @channel.bind &#39;new_message&#39;, @messageReceived
  @channel</code></pre>

<p>Twitter has keyboard shortcuts, we need to disable them when the user is typing. After the user hits <em>enter</em> we send the message to our server:</p>

<pre><code>enableTextBox: -&gt;
  textBox = @box.find(&#39;.chatboxtextarea&#39;)
  textBox.keypress (e) =&gt;
    e.stopPropagation()
  textBox.keydown (e) =&gt;
    e.stopPropagation()
    code = if e.keyCode then e.keyCode else e.which
    if code == 13
      text = textBox.val()
      textBox.val &quot;&quot;
      e.preventDefault()
      if text != &quot;&quot;
        data = uid: @friend.uid , text: text, channel_name: @channel_name
        QoP.Server.sendRequest(&#39;messages&#39;,data)
    return</code></pre>

<p>Eventually, we&#8217;ll also receive a message. Again, we render the message using handlebars template and append the message to the Panel. We also need to scroll the content all the way up to the top, so that we can read the message when it arrives.</p>

<pre><code>messageReceived: (data) =&gt;
  nickname = data.nickname
  message = JST[&#39;message&#39;](text: data.text, nickname: nickname)
  @box.find(&#39;.chatboxcontent&#39;).append(message)
  @box.find(&#39;.chatboxcontent&#39;).scrollTop 10000000
  return</code></pre>

<h2 id='conclusions'>Conclusions</h2>

<p>There&#8217;s a lot more to say, we still have to see how to use Omniauth to authenticate the user, how to use DelayedJob to fetch friends data in background, how to setup a custom Sprockets without Rails, and the database relations and models used.</p>

<p>But that will be the subject of the next post!</p>