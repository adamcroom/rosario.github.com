<h3 id='how_to_setup_sprockets_without_rails_self_referencial_association_with_datamapper_delayed_job_for_sinatra'>How to setup Sprockets without Rails. Self referencial association with DataMapper. Delayed job for Sinatra.</h3>

<h2 id='overview'>Overview</h2>

<p>In the previous post, we have seen how to embed a chat widget with Coffescript. We mainly covered javascript events sent from the server to the clients using <a href='http://www.pusher.com' title='pusher'>pusher</a>. In this post we will see how to setup Sprockets without Rails, we&#8217;ll cover self referential associations for friendship relations, and finally we&#8217;ll setup Delayed Job with Sinatra to fetch user&#8217;s friends in background.</p>

<h2 id='sprockets_without_rails'>Sprockets without Rails</h2>

<p>Sprockets is a utility to compile coffescript/javascript and stylesheets. It&#8217;s very useful when we write lots of javascript and we need a way to package all the files in a single <em>application.js</em>. It also supports <em>ECO</em> templates and automatically creates a global variable to store our javascript templates.</p>

<p>Blatantly taken from <a href='http://www.simonecarletti.com/blog/2011/09/using-sprockets-without-a-railsrack-project/' title='sprockets without rails'>sprockets without rails</a> courtesy of <a href='http://www.simonecarletti.com/' title='Simone Carletti'>Simone Carletti</a>, there is an effective way to setup Sprockets without Rails. The following code goes in a <strong>Rakefile.rb</strong>.</p>

<pre><code>  require &#39;rubygems&#39;
  require &#39;bundler&#39;
  require &#39;pathname&#39;
  require &#39;logger&#39;
  require &#39;fileutils&#39;
  require &#39;data_mapper&#39;

  Bundler.require

  ROOT        = Pathname(File.dirname(__FILE__))
  LOGGER      = Logger.new(STDOUT)
  BUNDLES     = %w( application.css application.js )
  BUILD_DIR   = ROOT.join(&quot;public&quot;)
  SOURCE_DIR  = ROOT.join(&quot;assets&quot;)



  task :compile do
    sprockets = Sprockets::Environment.new(ROOT) do |env|
      env.logger = LOGGER
    end
  
    sprockets.append_path(SOURCE_DIR.join(&#39;javascripts&#39;).to_s)
    sprockets.append_path(SOURCE_DIR.join(&#39;templates&#39;).to_s)
    sprockets.append_path(SOURCE_DIR.join(&#39;stylesheets&#39;).to_s)
  
    BUNDLES.each do |bundle|
      assets = sprockets.find_asset(bundle)
      prefix, basename = assets.pathname.to_s.split(&#39;/&#39;)[-2..-1]
      FileUtils.mkpath BUILD_DIR.join(prefix)
    
      assets.to_a.each do |asset|
        # strip filename.css.foo.bar.css multiple extensions
        realname = asset.pathname.basename.to_s.split(&quot;.&quot;)[0..1].join(&quot;.&quot;)
        asset.write_to(BUILD_DIR.join(prefix, realname))
      end
    
      assets.write_to(BUILD_DIR.join(prefix, basename))
    end
  end</code></pre>

<p>It is also useful to automatically save and compile javascript files without manually running rake tasks. To do so, we setup a <strong>watchr</strong> file, and install the gem <a href='https://github.com/mynyml/watchr' title='watchr'>watchr</a>.</p>

<pre><code>  def run_sprockets
    print &quot;\nCompiling... &quot;
    system(&#39;rake compile&#39;)
    print &quot;done.\n&quot;
  end

  Signal.trap(&#39;INT&#39;) { abort(&quot;\n&quot;) }
  watch( &#39;assets/javascripts/*&#39;) { run_sprockets}
  watch( &#39;assets/templates/*&#39;) { run_sprockets}</code></pre>

<h2 id='relationship_status_its_not_complicated'>Relationship status: It&#8217;s not complicated</h2>

<p>We use <a href='http://datamapper.org/' title='Datamapper'>Datamapper</a> to write database models. It&#8217;s relatively easy to use and we don&#8217;t have to worry about migrations (and that&#8217;s ok given this simplicity of this project). Documentation is really good, we reuse part of <em>Self referential many to many relationships</em> section in <a href='http://datamapper.org/docs/associations.html' title='Associations'>Associations</a> and we add few utility methods.</p>

<pre><code>  class User
    include DataMapper::Resource

    property :id,         Serial
    property :name,       String
    property :uid,        String, :required =&gt; true
    property :nickname,   String
    property :created_at, DateTime
    property :online,     Boolean, :default  =&gt; false

    has n, :friendships, :child_key =&gt; [ :source_id ]
    has n, :friends, self, :through =&gt; :friendships, :via =&gt; :target

    has n, :inverse_friendships, &#39;Friendship&#39;, :child_key =&gt;[:target_id]
    has n, :inverse_friends, self, :through =&gt;:inverse_friendships, :via =&gt;:source
    def online!
      self.online = true
      self.save
    end

    def friend?(friend)
      friends.first(:id =&gt;friend.id) or inverse_friends.first(:id=&gt;friend.id)
    end

    def offline!
      self.online = false
      self.save
    end

    def online_friends
      fs = friends.all(:online=&gt;true)
      ls = inverse_friends.all(:online=&gt;true)
      fs + ls
    end

  end

  class Friendship
    include DataMapper::Resource
    belongs_to :source, &#39;User&#39;, :key =&gt; true
    belongs_to :target, &#39;User&#39;, :key =&gt; true
  end</code></pre>

<p>We have added <strong>online</strong> and <strong>offline</strong> methods, a method to get online friends and the <em>inverse_friendship</em> relation. If user <em>A</em> is friend with user <em>B</em>, then it means <em>B</em> is also friend with <em>A</em>. We store this relation only once in the <strong>Friendship</strong> table and use the inverse friendship relation.</p>

<h2 id='omniauth_for_twitter_using_sinatra'>Omniauth for Twitter using Sinatra</h2>

<p><a href='https://github.com/intridea/omniauth' title='Omniauth'>Omniauth</a> makes it very easy to authenticate with Twitter. We just need to provide a callback method, and store the user informations.</p>

<pre><code>  get &#39;/auth/twitter/callback&#39; do

    auth = request.env[&quot;omniauth.auth&quot;]

    user = User.first_or_create({ :uid =&gt; auth[&quot;uid&quot;]}, {
      :uid =&gt; auth[&quot;uid&quot;],
      :nickname =&gt; auth[&quot;info&quot;][&quot;nickname&quot;],
      :name =&gt; auth[&quot;info&quot;][&quot;name&quot;],
      :created_at =&gt; Time.now 
    })

    if user.nickname.nil? or user.nickname.empty?
      user.nickname = auth[&quot;info&quot;][&quot;nickname&quot;]
      user.save
    end

    if user and user.nickname and user.friends.empty?
      puts &quot;User #{user.nickname} - Getting Friends&quot;
      job = LookupFriends.new(user.nickname)
      Delayed::Job.enqueue job
    end
    session[:user_id] = user.id

    redirect &#39;https://twitter.com&#39;
  end</code></pre>

<h2 id='sinatra_and_delayed_job'>Sinatra and Delayed Job</h2>

<p>In the previous code snippet we use <em>Delayed Job</em> to fetch out first friends list. To setup <a href='https://github.com/collectiveidea/delayed_job' title='delayed job'>delayed job</a> with Sinatra is a piece of cake. We need to define few <em>tasks</em> in our <em>Rakefile.rb</em>. Note that the following task are useful when we deploy the code to <a href='http://www.heroku.com' title='heroku'>heroku</a>.</p>

<pre><code>  task :environment do
    require &#39;delayed_job&#39;
    require &#39;delayed_job_data_mapper&#39;
    require &#39;./models&#39;
    require &#39;./job&#39;
    DataMapper.setup(:default, ENV[&#39;DATABASE_URL&#39;] || &quot;sqlite3://#{Dir.pwd}/db.sqlite3&quot;)
    DataMapper.finalize
  end


  namespace :jobs do
    desc &quot;Clear the delayed_job queue.&quot;
    task :clear =&gt; :environment do
      Delayed::Job.delete_all
    end
  
    desc &quot;Start a delayed_job worker.&quot;
    task :work =&gt; :environment do
      Delayed::Worker.new(
        :min_priority =&gt; ENV[&#39;MIN_PRIORITY&#39;], 
        :max_priority =&gt; ENV[&#39;MAX_PRIORITY&#39;]).start
    end
  end</code></pre>

<p>Delayed Job is now ready fetch users from Twitter, here it is how we do it:</p>

<pre><code>  class LookupFriends &lt; Struct.new(:nickname)

    def perform
      friends = Twitter.friend_ids(nickname.to_s)
      user = User.first(:nickname =&gt; nickname)
      if friends.ids
        friends.ids.each do |id|
          friend = User.first_or_create(:uid=&gt; id)
          user.friends &lt;&lt; friend unless user.friends.first(:uid=&gt; id)
        end
        user.save
      end
    end
  end</code></pre>

<h2 id='conclusions'>Conclusions</h2>

<p>In the previous post we&#8217;ve seen how to embed a chat widget inside a Twitter page, using pusher and CORS requests. Behind the scenes though there are few tricks to talk about. The widgets is a coffescript <em>single page</em> mini application. To glue Coffescript files together Sprockets is an important tool. The database used is quite simple, and it&#8217;s necessary to check for online or offline users. Finally, we&#8217;ve seen how to setup Delayed Job to fetch data in background, and populate the database with <em>friends</em> data.</p>